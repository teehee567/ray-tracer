#version 460

#define SAMPLES 8
#define BOUNCES 12
#define EPSILON 0.0001
#define MAX_BVH_DEPTH 64
#define AMBIENT_COLOR vec3(0.1, 0.1, 0.1)
#define AMBIENT_INTENSITY 0.1

#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_scalar_block_layout : enable
#extension GL_EXT_debug_printf : enable
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_EXT_samplerless_texture_functions : enable
#extension GL_NV_compute_shader_derivatives: enable


#include "imports/ray.comp"
#include "imports/random.comp"

/* AABB node of the BVH tree */
struct BvhNode {
    vec3 min;
    uint idx;
    vec3 max;
    uint amt;
};

/* Material of a Mesh.
 *
 * base_color           is the base color of the mesh;
 * emission             is strenght of the emitted light by the object per channel;
 * reflectivity         describes how reflective the object is (blends between lambertian and metallic);
 * roughness            describes how rough the reflective surface is;
 * is_glass             indicates whether the material will be rendered with a glass shader;
 * ior                  is the index of refractivity of the glass material, if is_glass is true;         
 * shaded_smooth        only valid for triangle meshes, determines whether normals are interpolated;
 */
struct Material {
    vec4 base_color;
    vec4 emission;
    float metallic;
    float roughness;
    float ior;
    float transmission;
    float specular;
    vec3 specular_color;
    float clearcoat;
    float clearcoat_roughness;
    vec4 motion_blur;
    bool shaded_smooth;
    uint base_color_tex;
    uint metallic_roughness_tex;
    uint normal_tex;
    uint emission_tex;
    uint specular_tex;
    uint clearcoat_tex;
};

// perf: these triangles are pretty huge.
// Since if not shaded smooth the normals are ignored, then they can be used to 
// store 2 triangle per triangle...
// Or maybe just remove the normals altogether
struct Triangle {
    uint material_idx;
    bool is_sphere;
    vec3[3] vertices;
    vec3[3] normals;
    vec2 uvs[3];
};

/* Record of a ray intersection.
 *
 * did_hit      indicates whether an intesection even happened;
 *              !! If no intersection happened, then the following fields are undefined !!
 * pos          is the physical location of the intersection;
 * normal       is the normal vector of the intersected surface;
 * t            is the value of the parametric variable for the ray equation;
 * material     is the material of the intersected mesh;
 */
struct HitRecord {
    bool did_hit;
    bool is_exiting;
    vec3 pos;
    vec3 normal;
    float t;
    Material material;
    vec2 uv;
    Triangle triangle;
};

layout (local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

// todo: look into inline uniform buffers for speed and small data
layout(std430, set = 0, binding = 0) uniform Camera {
    uvec2 resolution;
    vec2 uv;
    float focal_len;
    float focus_distance;
    float aperture_radius;
    uint frame;
    vec4 origin;
    mat4 rotation;
} camera;

layout(std430, set = 0, binding = 1) readonly buffer BvhBuffer {
    BvhNode nodes[];
} bvh;

layout(std430, set = 0, binding = 2) readonly buffer MaterialBuffer {
    Material get[]; // this makes the syntax a bit more readable: materials.get[3]
} materials;

layout(std430, set = 0, binding = 3) readonly buffer TriangleBuffer {
    Triangle get[];
} triangles;

layout(set = 0, binding = 4, rgba8) uniform image2D accumulator;
layout(set = 0, binding = 5) writeonly uniform image2D framebuffer;
layout(set = 0, binding = 6) uniform sampler2D textures[];

Ray generate_ray(vec2 frag_coord) {
    // Scale the virtual camera to make the UV plane coincide with the focus plane
    vec2 focus_plane_uv = camera.uv * (camera.focus_distance / camera.focal_len);

    // The distance between pixels in world-space
    vec2 pixel_delta = focus_plane_uv / camera.resolution;
    pixel_delta *= vec2(1, -1); // Y grows downwards in vulkan, so we have to invert it

    vec3 viewport_origin = vec3(-focus_plane_uv.x/2, focus_plane_uv.y/2, -camera.focus_distance) + // Top left of focus plane
                           vec3(pixel_delta/2, 0);  // Center the pixel

    vec3 pixel_coords = viewport_origin + 
                        vec3(pixel_delta * (frag_coord + pixel_offset(seed)), 0); // Jitter for anti-aliasing

    vec3 aperture_offset = vec3(random_disc(seed), 0) * camera.aperture_radius;

    // Vector from origin to pixel, rotated
    vec3 ray_direction = mat3(camera.rotation) * normalize(pixel_coords - aperture_offset);

    // Rotated aperture offset, shifted by camera origin 
    vec3 ray_origin = (mat3(camera.rotation) * aperture_offset) + camera.origin.xyz;

    Ray ray; 
    ray.direction = ray_direction;
    ray.origin = ray_origin;
    ray.time = pgc_random(seed);
    return ray;
}

vec3 background_color(Ray ray) {
    //float blend = 0.5 * ray.direction.y + 0.5;
    //return mix(vec3(0.6, 0.8, 1.0), vec3(0.2, 0.4, 1.0), blend);
    return vec3(0.6);
}

// Schlick approximation of Fresnel on glass
float schlick_reflectance(float cos_angle, float ior) {
    float r0 = (1 - ior) / (1 + ior);
    r0 = r0 * r0;
    return r0 + (1 - r0) * pow((1 - cos_angle), 5);
}

// Möller-Trumbore intersection algorithm (https://www.graphics.cornell.edu/pubs/1997/MT97.pdf)
HitRecord hit_triangle(Triangle triangle, Ray ray, bool interpolate_normals) {
    /* This algorithm uses barycentric coordinates to determine whether the intersection falls within
     * the triangle.
     *
     * O = ray.origin; D = ray.dir; A, B, C = triangle points; u, v, w = barycentric coords.
     * Check where they intersect by equating the coords to the ray function:
     *      O + t*D = w*A + u*B + v*C
     *      O + t*D = (1-u-v)*A + u*B + v*C
     *      -t*D + u*(B - A) + v*(C - A) = O - A
     *
     * That is a linear equation with the following form:
     * (uppercase is vector, represent a column)
     *      |             |   | t |   |     |
     *      | D, B-A, C-A | * | u | = | O-A |
     *      |             |   | v |   |     |
     *            (M        *  tuv  =   OA)
     *
     * To solve the equation, cramer's rule is used:
     *      t = det(M with OA replacing 1st col) / det(M)
     *      u = det(M with OA replacing 2nd col) / det(M)
     *      v = det(M with OA replacing 3rd col) / det(M)
     *
     * Finally, the determinants are calculated using the scalar triple product:
     *      det(M) = (D × C-A) ⋅ B-A = dot(cross(D, C-A), B-A)
     */
    HitRecord hit;
    hit.did_hit = false;

    // Get the normal vector of the plane the triangle lays on.
    // This is done by performing a cross product between two of the sides of the triangle.
    vec3 ab = triangle.vertices[1] - triangle.vertices[0];
    vec3 ac = triangle.vertices[2] - triangle.vertices[0];
    vec3 plane_normal = normalize(cross(ab, ac));

    // Check if the ray is parallel to the plane, in which case no hit can happen
    if (abs(dot(plane_normal, ray.direction)) < EPSILON) return hit;

    // motion blur
    vec3 blur_offset = materials.get[triangle.material_idx].motion_blur.xyz * ray.time;

    vec3 o = ray.origin - (triangle.vertices[0] + blur_offset);
    vec3 p = cross(ray.direction, ac);
    vec3 q = cross(o, ab);
    float inv_det = 1 / dot(p, ab);

    // Find t using cramer's rule, and make sure the intersection happens in front
    // of the camera
    float t = dot(q, ac) * inv_det;
    if (t < EPSILON) return hit;

    // Find the barycentric coordinates
    float u = dot(p, o) * inv_det;
    float v = dot(q, ray.direction) * inv_det;
    float w = 1 - u - v;    // to avoid gaps due to precision issues

    // Check bounds of the barycentric coordinates.
    vec3 coords = vec3(u, v, w);
    if (any(lessThan(coords, vec3(0))) || any(greaterThan(coords, vec3(1)))) return hit;

    hit.did_hit = true;
    hit.t = t;
    hit.pos = ray_at(ray, t);
    hit.is_exiting = dot(plane_normal, ray.direction) > 0;
    hit.uv = triangle.uvs[0] * w + 
             triangle.uvs[1] * u + 
             triangle.uvs[2] * v;

    if (interpolate_normals) {
        // Normalize after interpolation to ensure unit length
        hit.normal = normalize(triangle.normals[0] * w +
                              triangle.normals[1] * u +
                              triangle.normals[2] * v);
    } else {
        hit.normal = plane_normal;
    }

    return hit;
}

/*
 * AABB intersection code using the Slab method.
 *
 * This works by first solving the t parameter for each plane intersection, and
 * then checking if any of the intersections with the plane that should be closer
 * to the camera end up further away than the intersections of the opposite plane.
 *
 * More info at https://en.wikipedia.org/wiki/Slab_method
 */
float dist_aabb(Ray ray, BvhNode aabb) {
    vec3 inv_dir = 1 / ray.direction;

    // Solve for the intersection points with all 6 planes:
    // origin_x + t * direction_x = x  (for all 3 dimensions)
    vec3 t1 = (aabb.min - ray.origin) * inv_dir;
    vec3 t2 = (aabb.max - ray.origin) * inv_dir;

    // Get the closest and furthest intersections for each dimension
    vec3 d_min = min(t1, t2);
    vec3 d_max = max(t1, t2);

    float t_min = max(max(d_min.x, d_min.y), d_min.z);
    float t_max = min(min(d_max.x, d_max.y), d_max.z);

    bool did_hit = t_min <= t_max && t_max > 0;

    return did_hit ? t_min : 1.0 / 0.0; //infinity
}

// todo: this is recursive, might be optimizable to a loop
HitRecord hit_meshes(Ray ray, inout uint mesh_tests) {
    HitRecord hit;
    hit.t = 1.0 / 0.0; // infinity
    hit.did_hit = false;

    // Setup stack for tree traversal
    uint stack[MAX_BVH_DEPTH + 1], stack_ptr = 0;
    stack[stack_ptr++] = 0;

    while (stack_ptr > 0) {
        BvhNode node = bvh.nodes[stack[--stack_ptr]];

        mesh_tests++;
        // if it's a leaf, attempt to intersect its meshes
        if (node.amt != 0) {
            for (int tri = 0; tri < node.amt; tri++) {
                mesh_tests++;

                Triangle triangle = triangles.get[node.idx + tri];
                HitRecord current_hit;

                current_hit = hit_triangle(triangle, ray, materials.get[triangle.material_idx].shaded_smooth);

                if (current_hit.did_hit && current_hit.t < hit.t) {
                    hit = current_hit;
                    hit.material = materials.get[triangle.material_idx];
                    hit.triangle = triangle;
                }
            }

        // Else push both nodes on the stack, in order of closest to furthest
        // Only actually push nodes that can be closer than the already-hit
        } else {
            uint idx = node.idx;
            float dist_left =  dist_aabb(ray, bvh.nodes[idx + 0]);
            float dist_right = dist_aabb(ray, bvh.nodes[idx + 1]);

            if (dist_left < dist_right) {
                if (dist_right < hit.t) stack[stack_ptr++] = idx + 1;
                if (dist_left < hit.t)  stack[stack_ptr++] = idx;
            } else {
                if (dist_left < hit.t)  stack[stack_ptr++] = idx; 
                if (dist_right < hit.t) stack[stack_ptr++] = idx + 1;
            }
        }
    }

    return hit;
}

// Fresnel-Schlick approximation
vec3 F_Schlick(vec3 f0, float cos_theta) {
    return f0 + (1.0 - f0) * pow(1.0 - cos_theta, 5.0);
}

vec3 calculate_surface_normal(HitRecord hit, Triangle triangle) {
    if (hit.material.normal_tex == 0xFFFFFFFF) {
        return hit.normal;
    }

    // Calculate tangent space
    vec3 dp1 = triangle.vertices[1] - triangle.vertices[0];
    vec3 dp2 = triangle.vertices[2] - triangle.vertices[0];
    vec2 duv1 = triangle.uvs[1] - triangle.uvs[0];
    vec2 duv2 = triangle.uvs[2] - triangle.uvs[0];
    
    float inv_det = 1.0 / (duv1.x * duv2.y - duv1.y * duv2.x);
    vec3 tangent = normalize((dp1 * duv2.y - dp2 * duv1.y) * inv_det);
    vec3 bitangent = normalize((dp2 * duv1.x - dp1 * duv2.x) * inv_det);
    
    // Build TBN matrix
    mat3 TBN = mat3(tangent, bitangent, hit.normal);
    
    // Sample and decode normal map
    vec3 normal_map = texture(textures[nonuniformEXT(hit.material.normal_tex)], hit.uv).rgb;
    normal_map = normal_map * 2.0 - 1.0; // Convert from [0,1] to [-1,1]
    
    return normalize(TBN * normal_map);
}

vec3 ray_color(Ray ray, inout uint mesh_tests) {
    vec3 throughput = vec3(1.0);
    vec3 accumulated_light = vec3(0.0);
    
    for(int bounce = 0; bounce < BOUNCES; bounce++) {
        HitRecord hit = hit_meshes(ray, mesh_tests);
        
        if(!hit.did_hit) {
            accumulated_light += throughput * background_color(ray);
            break;
        }

        accumulated_light += throughput * AMBIENT_COLOR * AMBIENT_INTENSITY * hit.material.base_color.rgb;

        vec3 surface_normal = calculate_surface_normal(hit, hit.triangle);

        // Add emission immediately
        if(any(greaterThan(hit.material.emission.rgb, vec3(0.0)))) {
            vec3 emission = hit.material.emission.rgb;
            if(hit.material.emission_tex != 0xFFFFFFFF) {
                vec3 emission_tex = texture(textures[nonuniformEXT(hit.material.emission_tex)], hit.uv).rgb;
                // Only apply emission and break if the texture color is not black
                if(any(greaterThan(emission_tex, vec3(0.001)))) {
                    emission *= emission_tex;
                    accumulated_light += throughput * emission;
                    break;
                }
                // If texture is black, continue path tracing without breaking
            } else {
                accumulated_light += throughput * emission;
                break;
            }
        }

        // Get material properties
        vec3 base_color = hit.material.base_color.rgb;
        if(hit.material.base_color_tex != 0xFFFFFFFF) {
            base_color *= texture(textures[nonuniformEXT(hit.material.base_color_tex)], hit.uv).rgb;
        }

        float metallic = hit.material.metallic;
        float roughness = hit.material.roughness;
        if(hit.material.metallic_roughness_tex != 0xFFFFFFFF) {
            vec4 mr = texture(textures[nonuniformEXT(hit.material.metallic_roughness_tex)], hit.uv);
            metallic *= mr.b;
            roughness *= mr.g;
        }

        // Handle glass/transmission
        if(hit.material.transmission > 0.0) {
            vec3 normal = surface_normal;
            if(hit.is_exiting) {
                normal = -normal;
            }
            
            float ior_ratio = hit.is_exiting ? hit.material.ior : 1.0/hit.material.ior;
            float cos_theta = min(dot(-ray.direction, normal), 1.0);
            float reflectance = schlick_reflectance(cos_theta, ior_ratio);

            if(pgc_random(seed) < reflectance) {
                // Reflection
                ray.direction = reflect(ray.direction, normal);
            } else {
                // Refraction
                ray.direction = refract(ray.direction, normal, ior_ratio);
                if(length(ray.direction) == 0.0) {
                    // Total internal reflection
                    ray.direction = reflect(ray.direction, normal);
                }
            }
            
            ray.origin = hit.pos + ray.direction * 0.001; // Offset in the direction we're going
            
            // Only apply glass tint when exiting
            if(hit.is_exiting) {
                throughput *= base_color;
            }
            continue; // Skip the Russian Roulette for glass
        } 
        // Handle regular materials
        else {
            vec3 V = -ray.direction;
            vec3 N = surface_normal;
            
            // Base metallicity path
            vec3 F0 = mix(vec3(0.04), base_color, metallic);
            
            // Apply specular
            if (hit.material.specular > 0.0) {
                vec3 specular_factor = hit.material.specular_color * hit.material.specular;
                if(hit.material.specular_tex != 0xFFFFFFFF) {
                    specular_factor *= texture(textures[nonuniformEXT(hit.material.specular_tex)], hit.uv).rgb;
                }
                F0 = mix(F0, specular_factor, hit.material.specular);
            }

            float cos_theta = max(dot(N, V), 0.0);
            vec3 F = F_Schlick(F0, cos_theta);
            
            // Handle clearcoat
            float clearcoat = hit.material.clearcoat;
            if(hit.material.clearcoat_tex != 0xFFFFFFFF) {
                clearcoat *= texture(textures[nonuniformEXT(hit.material.clearcoat_tex)], hit.uv).r;
            }
            
            if(clearcoat > 0.0) {
                float clearcoat_rough = hit.material.clearcoat_roughness;
                vec3 clearcoat_F = F_Schlick(vec3(0.04), cos_theta);
                float clearcoat_prob = max(max(clearcoat_F.r, clearcoat_F.g), clearcoat_F.b) * clearcoat;
                
                if(pgc_random(seed) < clearcoat_prob) {
                    // Clearcoat reflection
                    vec3 reflected = reflect(-V, N);
                    ray.direction = normalize(reflected + clearcoat_rough * random_unit_vector(seed));
                    throughput *= clearcoat_F * clearcoat / clearcoat_prob;
                    ray.origin = hit.pos + N * 0.001;
                    continue;
                }
            }

            float specular_prob = max(max(F.r, F.g), F.b);
            
            if(pgc_random(seed) < specular_prob) {
                // Specular reflection
                vec3 reflected = reflect(-V, N);
                ray.direction = normalize(reflected + roughness * random_unit_vector(seed));
                throughput *= F / specular_prob;
            } else {
                // Diffuse reflection
                ray.direction = normalize(N + random_unit_vector(seed));
                throughput *= base_color * (1.0 - F) / (1.0 - specular_prob);
            }
            
            ray.origin = hit.pos + N * 0.001;
        }
        
        // Russian Roulette
        if(bounce > 2) {
            float p = max(0.05, max(throughput.r, max(throughput.g, throughput.b))); // Minimum probability
            if(pgc_random(seed) > p) {
                break;
            }
            throughput /= p;
        }
    }
    
    return accumulated_light;
}

// ACES tone mapping curve fit
// Source: https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/
vec3 aces_film(vec3 x) {
    float a = 2.51f;
    float b = 0.03f;
    float c = 2.43f;
    float d = 0.59f;
    float e = 0.14f;
    return clamp((x * (a * x + b)) / (x * (c * x + d) + e), 0.0, 1.0);
}

// Alternative tone mapping operator (Reinhard)
vec3 reinhard(vec3 x) {
    return x / (1.0 + x);
}
vec3 rgb_to_hsv(vec3 rgb) {
    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
    vec4 p = mix(vec4(rgb.bg, K.wz), vec4(rgb.gb, K.xy), step(rgb.b, rgb.g));
    vec4 q = mix(vec4(p.xyw, rgb.r), vec4(rgb.r, p.yzx), step(p.x, rgb.r));
    
    float d = q.x - min(q.w, q.y);
    float e = 1.0e-10;
    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
}
vec3 hsv_to_rgb(vec3 hsv) {
    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
    vec3 p = abs(fract(hsv.xxx + K.xyz) * 6.0 - K.www);
    return hsv.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), hsv.y);
}

// Adjusts saturation using HSV
vec3 adjust_saturation(vec3 color, float saturation) {
    vec3 hsv = rgb_to_hsv(color);
    hsv.y *= saturation;  // Multiply saturation
    return hsv_to_rgb(hsv);
}

// Extended Reinhard tone mapping with white point
vec3 reinhard_extended(vec3 x, float white_point) {
    vec3 numerator = x * (1.0 + (x / (white_point * white_point)));
    return numerator / (1.0 + x);
}

vec4 gamma_correction(vec4 color) {
    // Apply tone mapping first
    vec3 tone_mapped = aces_film(color.rgb);

    float saturation = 1.5;  // Adjust this value (1.0 is normal, >1.0 increases saturation)
    tone_mapped = adjust_saturation(tone_mapped, saturation);
    
    // Then apply gamma correction
    vec3 gamma_corrected = pow(tone_mapped, vec3(1.0/2.2));
    
    return vec4(gamma_corrected, color.a);
}

void main() {
    ivec2 coordinates = ivec2(gl_GlobalInvocationID.xy);
    ivec2 size = imageSize(framebuffer);

    if (coordinates.x < size.x && coordinates.y < size.y) {
        seed = uint(coordinates.x + camera.resolution.x * coordinates.y + camera.frame * coordinates.y * coordinates.x);
        uint mesh_tests = 0;
        vec3 color = vec3(0);
        for (int i = 0; i < SAMPLES; i++) {
            Ray ray = generate_ray(coordinates.xy);

            color += ray_color(ray, mesh_tests) / float(SAMPLES);
        }

        //color = clamp(color, vec3(0), vec3(1));

        vec4 old_pixel = imageLoad(accumulator, coordinates);
        vec4 new_pixel = old_pixel * camera.frame / (camera.frame + 1) + vec4(color, 1.0) / (camera.frame + 1);

        imageStore(accumulator, coordinates, new_pixel);
        imageStore(framebuffer, coordinates, gamma_correction(new_pixel));

        // visualize triangle tests
        //float tests = float(mesh_tests) / 3000.0f;
        //imageStore(framebuffer, coordinates, gamma_correction(vec4(tests <= 1.0f ? vec3(tests) : vec3(1,0,0), 1.0)));

        //imageStore(framebuffer, coordinates, gamma_correction(vec4(color, 1.0)));
        //imageStore(framebuffer, coordinates, gamma_correction(vec4(triangle_sbo.triangles[0].first, 1.0)));
    }
}
