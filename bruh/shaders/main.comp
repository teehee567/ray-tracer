#version 460

#define SAMPLES 8
#define BOUNCES 12
#define EPSILON 0.0001
#define MAX_BVH_DEPTH 64
#define AMBIENT_COLOR vec3(0.1, 0.1, 0.1)
#define AMBIENT_INTENSITY 0.1
#define INFINITY 10000000.

#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_scalar_block_layout : enable
#extension GL_EXT_debug_printf : enable
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_EXT_samplerless_texture_functions : enable
#extension GL_NV_compute_shader_derivatives: enable


#include "imports/ray.comp"
#include "imports/global.comp"
#include "imports/random.comp"
#include "imports/disney.comp"

/* AABB node of the BVH tree */
struct BvhNode {
    vec3 min;
    uint idx;
    vec3 max;
    uint amt;
};


// perf: these triangles are pretty huge.
// Since if not shaded smooth the normals are ignored, then they can be used to 
// store 2 triangle per triangle...
// Or maybe just remove the normals altogether


layout (local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

// todo: look into inline uniform buffers for speed and small data
layout(std430, set = 0, binding = 0) uniform Camera {
    uvec2 resolution;
    vec2 uv;
    float focal_len;
    float focus_distance;
    float aperture_radius;
    uint frame;
    vec4 origin;
    mat4 rotation;
} camera;

layout(std430, set = 0, binding = 1) readonly buffer BvhBuffer {
    BvhNode nodes[];
} bvh;

layout(std430, set = 0, binding = 2) readonly buffer MaterialBuffer {
    Material get[]; // this makes the syntax a bit more readable: materials.get[3]
} materials;

layout(std430, set = 0, binding = 3) readonly buffer TriangleBuffer {
    Triangle get[];
} triangles;

layout(set = 0, binding = 4, rgba8) uniform image2D accumulator;
layout(set = 0, binding = 5) writeonly uniform image2D framebuffer;
layout(set = 0, binding = 6) uniform sampler2D textures[];

Ray generate_ray(vec2 frag_coord) {
    // Scale the virtual camera to make the UV plane coincide with the focus plane
    vec2 focus_plane_uv = camera.uv * (camera.focus_distance / camera.focal_len);

    // The distance between pixels in world-space
    vec2 pixel_delta = focus_plane_uv / camera.resolution;
    pixel_delta *= vec2(1, -1); // Y grows downwards in vulkan, so we have to invert it

    vec3 viewport_origin = vec3(-focus_plane_uv.x/2, focus_plane_uv.y/2, -camera.focus_distance) + // Top left of focus plane
                           vec3(pixel_delta/2, 0);  // Center the pixel

    vec3 pixel_coords = viewport_origin + 
                        vec3(pixel_delta * (frag_coord + pixel_offset(seed)), 0); // Jitter for anti-aliasing

    vec3 aperture_offset = vec3(random_disc(seed), 0) * camera.aperture_radius;

    // Vector from origin to pixel, rotated
    vec3 ray_direction = mat3(camera.rotation) * normalize(pixel_coords - aperture_offset);

    // Rotated aperture offset, shifted by camera origin 
    vec3 ray_origin = (mat3(camera.rotation) * aperture_offset) + camera.origin.xyz;

    Ray ray; 
    ray.direction = ray_direction;
    ray.origin = ray_origin;
    ray.time = pgc_random(seed);
    return ray;
}

vec3 background_color(Ray ray) {
    //float blend = 0.5 * ray.direction.y + 0.5;
    //return mix(vec3(0.6, 0.8, 1.0), vec3(0.2, 0.4, 1.0), blend);
    return vec3(0.6);
}

// Möller-Trumbore intersection algorithm (https://www.graphics.cornell.edu/pubs/1997/MT97.pdf)
HitRecord hit_triangle(Triangle triangle, Ray ray, bool interpolate_normals) {
    /* This algorithm uses barycentric coordinates to determine whether the intersection falls within
     * the triangle.
     *
     * O = ray.origin; D = ray.dir; A, B, C = triangle points; u, v, w = barycentric coords.
     * Check where they intersect by equating the coords to the ray function:
     *      O + t*D = w*A + u*B + v*C
     *      O + t*D = (1-u-v)*A + u*B + v*C
     *      -t*D + u*(B - A) + v*(C - A) = O - A
     *
     * That is a linear equation with the following form:
     * (uppercase is vector, represent a column)
     *      |             |   | t |   |     |
     *      | D, B-A, C-A | * | u | = | O-A |
     *      |             |   | v |   |     |
     *            (M        *  tuv  =   OA)
     *
     * To solve the equation, cramer's rule is used:
     *      t = det(M with OA replacing 1st col) / det(M)
     *      u = det(M with OA replacing 2nd col) / det(M)
     *      v = det(M with OA replacing 3rd col) / det(M)
     *
     * Finally, the determinants are calculated using the scalar triple product:
     *      det(M) = (D × C-A) ⋅ B-A = dot(cross(D, C-A), B-A)
     */
    HitRecord hit;
    hit.did_hit = false;
    hit.hit_dist = INFINITY;
    hit.eta = 1.;
    hit.is_exiting = false;
    hit.triangle = triangle;

    // Get the normal vector of the plane the triangle lays on.
    // This is done by performing a cross product between two of the sides of the triangle.
    vec3 ab = triangle.vertices[1] - triangle.vertices[0];
    vec3 ac = triangle.vertices[2] - triangle.vertices[0];
    vec3 plane_normal = normalize(cross(ab, ac));

    // Check if the ray is parallel to the plane, in which case no hit can happen
    if (abs(dot(plane_normal, ray.direction)) < EPSILON) return hit;

    vec3 o = ray.origin - triangle.vertices[0];
    vec3 p = cross(ray.direction, ac);
    vec3 q = cross(o, ab);
    float inv_det = 1 / dot(p, ab);

    // Find t using cramer's rule, and make sure the intersection happens in front
    // of the camera
    float t = dot(q, ac) * inv_det;
    if (t < EPSILON) return hit;

    // Find the barycentric coordinates
    float u = dot(p, o) * inv_det;
    float v = dot(q, ray.direction) * inv_det;
    float w = 1 - u - v;    // to avoid gaps due to precision issues

    // Check bounds of the barycentric coordinates.
    vec3 coords = vec3(u, v, w);
    if (any(lessThan(coords, vec3(0))) || any(greaterThan(coords, vec3(1)))) return hit;

    hit.did_hit = true;
    hit.hit_dist = t;
    hit.pos = ray_at(ray, t);
    hit.is_exiting = dot(plane_normal, ray.direction) > 0;
    hit.uv = triangle.uvs[0] * w + 
             triangle.uvs[1] * u + 
             triangle.uvs[2] * v;

    if (interpolate_normals) {
        // Normalize after interpolation to ensure unit length
        hit.normal = normalize(triangle.normals[0] * w +
                              triangle.normals[1] * u +
                              triangle.normals[2] * v);
    } else {
        hit.normal = plane_normal;
    }

    hit.ffnormal = dot(hit.normal, ray.direction) < 0 ? hit.normal : -hit.normal;

    vec3 edge1 = triangle.vertices[1] - triangle.vertices[0];
    vec3 edge2 = triangle.vertices[2] - triangle.vertices[0];
    vec2 duv1 = triangle.uvs[1] - triangle.uvs[0];
    vec2 duv2 = triangle.uvs[2] - triangle.uvs[0];

    float f = 1.0 / (duv1.x * duv2.y - duv2.x * duv1.y);
    hit.tangent = normalize(f * (duv2.y * edge1 - duv1.y * edge2));
    hit.bitangent = normalize(f * (-duv2.x * edge1 + duv1.x * edge2));

    return hit;
}

/*
 * AABB intersection code using the Slab method.
 *
 * This works by first solving the t parameter for each plane intersection, and
 * then checking if any of the intersections with the plane that should be closer
 * to the camera end up further away than the intersections of the opposite plane.
 *
 * More info at https://en.wikipedia.org/wiki/Slab_method
 */
float dist_aabb(Ray ray, BvhNode aabb) {
    vec3 inv_dir = 1 / ray.direction;

    // Solve for the intersection points with all 6 planes:
    // origin_x + t * direction_x = x  (for all 3 dimensions)
    vec3 t1 = (aabb.min - ray.origin) * inv_dir;
    vec3 t2 = (aabb.max - ray.origin) * inv_dir;

    // Get the closest and furthest intersections for each dimension
    vec3 d_min = min(t1, t2);
    vec3 d_max = max(t1, t2);

    float t_min = max(max(d_min.x, d_min.y), d_min.z);
    float t_max = min(min(d_max.x, d_max.y), d_max.z);

    bool did_hit = t_min <= t_max && t_max > 0;

    return did_hit ? t_min : 1.0 / 0.0; //infinity
}

// todo: this is recursive, might be optimizable to a loop
HitRecord hit_meshes(Ray ray, inout uint mesh_tests) {
    HitRecord hit;
    hit.hit_dist = 1.0 / 0.0; // infinity
    hit.did_hit = false;

    // Setup stack for tree traversal
    uint stack[MAX_BVH_DEPTH + 1], stack_ptr = 0;
    stack[stack_ptr++] = 0;

    while (stack_ptr > 0) {
        BvhNode node = bvh.nodes[stack[--stack_ptr]];

        mesh_tests++;
        // if it's a leaf, attempt to intersect its meshes
        if (node.amt != 0) {
            for (int tri = 0; tri < node.amt; tri++) {
                mesh_tests++;

                Triangle triangle = triangles.get[node.idx + tri];
                HitRecord current_hit;

                current_hit = hit_triangle(triangle, ray, materials.get[triangle.material_idx].shaded_smooth);

                if (current_hit.did_hit && current_hit.hit_dist < hit.hit_dist) {
                    hit = current_hit;
                    hit.material = materials.get[triangle.material_idx];
                    hit.triangle = triangle;
                }
            }

        // Else push both nodes on the stack, in order of closest to furthest
        // Only actually push nodes that can be closer than the already-hit
        } else {
            uint idx = node.idx;
            float dist_left =  dist_aabb(ray, bvh.nodes[idx + 0]);
            float dist_right = dist_aabb(ray, bvh.nodes[idx + 1]);

            if (dist_left < dist_right) {
                if (dist_right < hit.hit_dist) stack[stack_ptr++] = idx + 1;
                if (dist_left < hit.hit_dist)  stack[stack_ptr++] = idx;
            } else {
                if (dist_left < hit.hit_dist)  stack[stack_ptr++] = idx; 
                if (dist_right < hit.hit_dist) stack[stack_ptr++] = idx + 1;
            }
        }
    }

    return hit;
}

vec3 calculate_surface_normal(HitRecord hit, Triangle triangle) {
    if (hit.material.normal_tex == 0xFFFFFFFF) {
        return hit.normal;
    }

    // Calculate tangent space
    vec3 dp1 = triangle.vertices[1] - triangle.vertices[0];
    vec3 dp2 = triangle.vertices[2] - triangle.vertices[0];
    vec2 duv1 = triangle.uvs[1] - triangle.uvs[0];
    vec2 duv2 = triangle.uvs[2] - triangle.uvs[0];
    
    float inv_det = 1.0 / (duv1.x * duv2.y - duv1.y * duv2.x);
    vec3 tangent = normalize((dp1 * duv2.y - dp2 * duv1.y) * inv_det);
    vec3 bitangent = normalize((dp2 * duv1.x - dp1 * duv2.x) * inv_det);
    
    // Build TBN matrix
    mat3 TBN = mat3(tangent, bitangent, hit.normal);
    
    // Sample and decode normal map
    vec3 normal_map = texture(textures[nonuniformEXT(hit.material.normal_tex)], hit.uv).rgb;
    normal_map = normal_map * 2.0 - 1.0; // Convert from [0,1] to [-1,1]
    
    return normalize(TBN * normal_map);
}

vec3 ray_color(Ray ray, inout uint mesh_tests) {
    vec3 radiance = vec3(0.0);
    vec3 throughput = vec3(1.0);
    LightSampleRec lightSampleRec;
    BsdfSampleRec bsdfSampleRec;

    initLights();
    numOfLights = NUM_LIGHTS;
    
    for(int bounce = 0; bounce < BOUNCES; bounce++) {
        HitRecord hit = hit_meshes(ray, mesh_tests);
        
        if(!hit.did_hit) {
            radiance += getBackground(ray) * throughput;
        } else {
            hit.ffnormal = dot(hit.normal, ray.direction) <= 0.0 ? hit.normal : -hit.normal;
            Onb(hit.normal, hit.tangent, hit.bitangent);
            hit.material.roughness = max(hit.material.roughness, 0.001);
            hit.eta = dot(hit.normal, hit.ffnormal) > 0.0 ? (1.0 / hit.material.ior) : hit.material.ior;
        }

        radiance += hit.material.emission.xyz * throughput;

        //vec3 surface_normal = calculate_surface_normal(hit, hit.triangle);

        if (any(greaterThan(hit.material.emission.xyz, vec3(EPSILON)))) {
            radiance += EmitterSample(ray, bounce, lightSampleRec, bsdfSampleRec) * throughput;
            break;
        }

        if (dot(hit.normal, hit.ffnormal) < 0.0 && hit.material.spec_trans > 0.0) {
            throughput *= exp(-log(hit.material.base_color.rgb) * hit.hit_dist);
        }

        radiance += DirectLight(ray, hit) * throughput;

        bsdfSampleRec.f = DisneySample(hit, -ray.direction, hit.ffnormal, bsdfSampleRec.L, bsdfSampleRec.pdf);

        if (bsdfSampleRec.pdf > 0.0) {
            throughput *= bsdfSampleRec.f / bsdfSampleRec.pdf;
        } else {
            break;
        }
        
        // Russian Roulette
        if(bounce > 2) {
            float p = max(0.05, max(throughput.r, max(throughput.g, throughput.b)));
            if(pgc_random(seed) > p) {
                break;
            }
            throughput /= p;
        }
        ray.direction = bsdfSampleRec.L;
        ray.origin = hit.pos + ray.direction * EPSILON;
    }
    
    return radiance;
}

// ACES tone mapping curve fit
// Source: https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/
vec3 aces_film(vec3 x) {
    float a = 2.51f;
    float b = 0.03f;
    float c = 2.43f;
    float d = 0.59f;
    float e = 0.14f;
    return clamp((x * (a * x + b)) / (x * (c * x + d) + e), 0.0, 1.0);
}

// Alternative tone mapping operator (Reinhard)
vec3 reinhard(vec3 x) {
    return x / (1.0 + x);
}
vec3 rgb_to_hsv(vec3 rgb) {
    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
    vec4 p = mix(vec4(rgb.bg, K.wz), vec4(rgb.gb, K.xy), step(rgb.b, rgb.g));
    vec4 q = mix(vec4(p.xyw, rgb.r), vec4(rgb.r, p.yzx), step(p.x, rgb.r));
    
    float d = q.x - min(q.w, q.y);
    float e = 1.0e-10;
    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
}
vec3 hsv_to_rgb(vec3 hsv) {
    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
    vec3 p = abs(fract(hsv.xxx + K.xyz) * 6.0 - K.www);
    return hsv.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), hsv.y);
}

// Adjusts saturation using HSV
vec3 adjust_saturation(vec3 color, float saturation) {
    vec3 hsv = rgb_to_hsv(color);
    hsv.y *= saturation;  // Multiply saturation
    return hsv_to_rgb(hsv);
}

// Extended Reinhard tone mapping with white point
vec3 reinhard_extended(vec3 x, float white_point) {
    vec3 numerator = x * (1.0 + (x / (white_point * white_point)));
    return numerator / (1.0 + x);
}

vec4 gamma_correction(vec4 color) {
    // Apply tone mapping first
    vec3 tone_mapped = aces_film(color.rgb);

    float saturation = 1.5;  // Adjust this value (1.0 is normal, >1.0 increases saturation)
    tone_mapped = adjust_saturation(tone_mapped, saturation);
    
    // Then apply gamma correction
    vec3 gamma_corrected = pow(tone_mapped, vec3(1.0/2.2));
    
    return vec4(gamma_corrected, color.a);
}

void main() {
    ivec2 coordinates = ivec2(gl_GlobalInvocationID.xy);
    ivec2 size = imageSize(framebuffer);

    if (coordinates.x < size.x && coordinates.y < size.y) {
        seed = uint(coordinates.x + camera.resolution.x * coordinates.y + camera.frame * coordinates.y * coordinates.x);
        uint mesh_tests = 0;
        vec3 color = vec3(0);
        for (int i = 0; i < SAMPLES; i++) {
            Ray ray = generate_ray(coordinates.xy);

            color += ray_color(ray, mesh_tests) / float(SAMPLES);
        }

        //color = clamp(color, vec3(0), vec3(1));

        vec4 old_pixel = imageLoad(accumulator, coordinates);
        vec4 new_pixel = old_pixel * camera.frame / (camera.frame + 1) + vec4(color, 1.0) / (camera.frame + 1);

        imageStore(accumulator, coordinates, new_pixel);
        imageStore(framebuffer, coordinates, gamma_correction(new_pixel));

        // visualize triangle tests
        //float tests = float(mesh_tests) / 3000.0f;
        //imageStore(framebuffer, coordinates, gamma_correction(vec4(tests <= 1.0f ? vec3(tests) : vec3(1,0,0), 1.0)));

        //imageStore(framebuffer, coordinates, gamma_correction(vec4(color, 1.0)));
        //imageStore(framebuffer, coordinates, gamma_correction(vec4(triangle_sbo.triangles[0].first, 1.0)));
    }
}
